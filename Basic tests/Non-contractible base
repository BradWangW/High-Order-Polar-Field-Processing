import numpy as np
from tqdm import tqdm
from collections import defaultdict
import os
import networkx as nx

def load_off_file(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()

    # Parse the vertices and faces from the OFF file
    num_vertices, num_faces, _ = map(int, lines[1].split())

    vertices = np.array([list(map(float, line.split())) for line in lines[2:2 + num_vertices]])
    faces = np.array([list(map(int, line.split()))[1:] for line in lines[2 + num_vertices:]])

    return vertices, faces
        
def obtain_E(F):
    '''
    Obtain the edge list from the face list.
    '''
    E = np.concatenate([
        F[:, [0, 1]], F[:, [1, 2]], F[:, [2, 0]]
    ])
    E = np.unique(np.sort(E, axis=1), axis=0)
    
    return E

def get_E_dual(V, E, F):
    '''
    Construct the dual graph
    '''
    E_dual = np.zeros((E.shape[0], 2), dtype=int)
    
    # Construct the dual edges
    for i, edge in enumerate(E):
        faces = np.where(np.isin(F, edge).sum(axis=1) == 2)[0]
        if len(faces) == 2:
            E_dual[i] = faces
        else:
            raise ValueError(f'Edge {edge} is not shared by exactly 2 faces.')
    
    return E_dual

def find_noncontractible_cycles(E):
    E_tuple = [tuple(e) for e in E]
    E_dual = get_E_dual(V, E, F)
    
    # Create a graph from the mesh edges
    G = nx.Graph()
    G.add_edges_from(E_tuple)
    
    T = nx.minimum_spanning_tree(G)
    
    E_included = np.any((E[:, None] == np.array(T.edges())).all(-1), axis=1)
    E_dual_tuple = [tuple(e) for e in E_dual[~E_included]]
    
    # Construct the dual graph, where the edges 
    # of the previous spanning tree are removed
    G_dual = nx.Graph()
    G_dual.add_edges_from(E_dual_tuple)
    T_dual = nx.minimum_spanning_tree(G_dual)
    
    # List to store non-contractible cycles
    noncontractible_cycles = []
    
    # Track all cycles for later filtering
    all_cycles = []

    for cotree_edge in tqdm(cotree_edges, 
                            desc="Finding non-contractible cycles", 
                            total=len(cotree_edges), 
                            leave=False):
        # Add the cotree edge back to form a cycle
        T.add_edge(*cotree_edge)
        
        # Find the cycle created by adding this edge
        cycle = nx.find_cycle(T, source=cotree_edge[0])
        all_cycles.append(cycle)
        
        # Remove the edge again to restore the tree
        T.remove_edge(*cotree_edge)
    print(len(all_cycles))
    lens_cycles = np.array([len(cycle) for cycle in all_cycles])
    print(np.unique(lens_cycles, return_counts=True))
    
    raise
    # Use the boundary operator to filter out contractible cycles
    # Simple heuristic: check if cycle is a boundary of some 2D region in the mesh
    for cycle in all_cycles:
        if not is_contractible(G, cycle):
            noncontractible_cycles.append(cycle)

    return noncontractible_cycles

def is_contractible(G, cycle):
    # Basic heuristic: a contractible cycle would usually bound a face in a planar graph
    subgraph = G.subgraph([v for edge in cycle for v in edge])
    if nx.is_planar(subgraph):
        # More advanced checks can be added here
        return True
    return False

# Example usage
V, F = load_off_file(os.path.join('..', 'data', 'Kitten.off'))
E = obtain_E(F)

primal_cycles = find_noncontractible_cycles(mesh_edges)
print("Primal Non-Contractible Cycles:")
for cycle in primal_cycles:
    print(cycle)